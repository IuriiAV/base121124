package com.telran.prof.lessoons.lesson9;

import java.util.HashSet;
import java.util.Set;

/**
 * HashSet - набор уникальных элементов без какого - либо порядка
 * ("мешок уникальных элементов" - на собесе не говорить мешок)
 *
 * add, remove, contains - O(1)
 * (в случае корректной реализации хешкода)
 *
 * HashSet -> HashMap -> Хеш таблица
 * -> это значит что во всех манипуляциях с данной коллекцией, участвует
 * хеш код объекта
 *
 * У каждого объекта в Java можно вычислить hashcode
 * он вычисляется с помощью метода hashcode из класса Object
 * Хешкод это целое число типа int
 *
 * Внутри HS -> HM -> массив из 16 элементов
 * ячейки внутри этого массива называются бакетами
 *
 * Что происходит когда вызываем метод add для добавления элемента:
 * 1) У добавляемого элемента вызывается метод hashCode O(1)
 * 2) Используя полученное значение и длину внутреннего массива нашего HS
 * мы вычисляем нужную ячейку массива (индекс) в которую должны поместить элемент O(1)
 * 3) Если вычисленная ячейка пустая, то там создается связный список и наш элемент
 * становится головой нашего связного списка O(1)
 *
 * Таким образом внутри HS -> массив связных списков
 *
 * В идеальном мире, при правильной реализации хешкода объекта,
 * HS -> всегда заполнен на 75% максимум, и в каждой ячейке лежит только
 * по одному элементу в голове связного списка
 *
 * Если массив переполнен он увеличивается в 2 раза
 *
 * Но иногда бывает так что у двух разных объектов - одинаковый хешкод и эти
 * попадают в одну корзину(индекс основан на хешкоде и длине массива)
 * // (Alex) 555 - 10 hash -> index 4 -> head LL
 * // (Oleg) 555 - 10 hash -> index 4 -> head LL(Oleg) -> (Alex) O(n)
 * В такой ситуации будут перебраны все элементы связного списка и они будут
 * сравниваться через метод equals с тем объектом с тем объектом, который мы туда пытаемся поместить
 * и если совпадений не найдется - это не дубль, то новый объект становится в голову LL
 *
 * Что происходит когда ищем элемент через contains:
 * 1) У искомого элемента вызывается метод hashCode O(1)
 * 2) Используя полученное значение и длину внутреннего массива нашего HS
 * мы вычисляем нужную ячейку массива (индекс) где должен находится элемент
 * который мы ищем O(1)
 * 3) Если вычисленная ячейка пустая, то вернем false, если там есть связный список
 * с одним элементом в голове, то сравним его с тем, который ищем через equals и если они одинаковые, то вернем true
 *
 * Если в сявзном списке больше чем один элемент, то будем перебирать и сравнивать и если
 * найдем, то вернем true иначе false O(n)
 *
 * 1) У двух одинаковых объектов всегда одинаковый хешкод
 * 2) У одного объекта хешкод всегда постоянен
 * 3) Хешкод это быстрый способ сравнения объектов:
 * 1) Если у двух объектов хешкоды разные, то объекты точно разные!!!!
 * 2) Если у двух объектов хешкоды одинаковые, то тогда нужно сравнить
 * эти объекты через equals, так как это могут быть разные объекты, а хешкод
 * будет коллизией
 *
 * Изначально элементов 16, когда мы достигаем заполнения 75%, то внутренний массив
 * увеличивается в 2 раза до 32 и так как позиция элементов (индекс ячейки где он хранится)
 * зависит от хешкода и длинны массива, то при изменении размера, для всех элементов,
 * что хранятся в нашем сете будут пересчитаны индексы ячеек, то они переместятся в новые ячейки
 */

public class HashSetExample {

    public static void main(String[] args) {
        Set<String> stringSet = new HashSet<>();
        stringSet.add("A");
        stringSet.add("C");
        stringSet.add("F");
        stringSet.add("D");
        stringSet.add("A");
        stringSet.add("B");
        stringSet.add("J");
        stringSet.add("e");

        System.out.println("Set contains F " + stringSet.contains("F"));

        System.out.println(stringSet);

        Set<Integer> integerSet = new HashSet<>();

        integerSet.add(8);
        integerSet.add(9);
        integerSet.add(-1);
        integerSet.add(4);
        integerSet.add(7);
        integerSet.add(-2);
        integerSet.remove(9);
        System.out.println(integerSet);
    }
}
