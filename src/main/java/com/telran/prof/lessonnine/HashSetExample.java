package com.telran.prof.lessonnine;

import java.util.HashSet;
import java.util.Hashtable;
import java.util.Set;

/**
 * HashSet - набор уникальных элементов, без какого либо порядка
 * ("мешок уникальных элементов" - на собесе не говорить про мешок)
 *
 * add, remove, contains - O(1)
 * (в случае корректной реализации хэшкода)
 *
 * HashSet -> HashMap -> Хэш таблица
 * -> это значит что во всех манипуляциях с данной коллекцией, участвует
 * хэш код объекта
 *
 * У каждого объекта в джаве можно вычислить hashcode
 * он вычисляется с помощью метода hashcode из класса Object
 * Хэшкод это целое число типа int
 *
 * Внутри HS -> HM -> массив из 16 элементов
 * ячейки этого массива называются бакетами
 *
 * Что происходит когда вызываем метод add для добавления элемента:
 * 1) У добавляемого элемента вызывается метод hashCode O(1)
 * 2)Хэшкод элемента передаем в функцию hash, которая возвращает некое число и
 * используя полученное значение и длину внутреннего массива нашего HS
 * мы вычисляем нужную ячейку массива (индекс) в которую должны поместить элемент O(1)
 * 3) Если вычисленная ячейка пустая, то там создается связный список и наш элемент
 * становится головой нашего связного списка O(1)
 *
 * Таким образом внутри HS -> массив связных списков
 *
 * В идеальном мире, при правильной реализации хэшкода объекта,
 * HS -> всегда заполнен на 75 % максимум, и в каждой ячейке лежит только
 * по одному элементу в голове связного списка
 *
 * Но иногда бывает так, то у двух разных объектов - одинаковый хэшкод и эти
 * попадают в одну корзину(индекс основан на хэшкоде и длине массива)
 * // (Alex) 555 - 10 hash -> index 4 - > head LL(Alex)
 * // (Oleg) 555 - 10 hash -> index 4 ->  head LL(Oleg) -> (Alex) O(n)
 * В такой ситуации будут перебраны все элементы связного списка и они будут
 * сравнивать через метод equals с тем объектом, который мы туда пытаемся поместить
 * и если совпадений не найдется-те это не дубль, то новый объект вставится в голову LL
 *
 * Что происходит, когда ищем элемент через contains:
 * 1) У искомого элемента вызывается метод hashCode O(1)
 * 2) Хэшкод элемента передаем в функцию hash, которая возвращает некое число и
 * и спользуя полученное значение и длину внутреннего массива нашего HS
 * мы вычисляем нужную ячейку массива (индекс) где должен находится тот элемент
 * который мы ищем O(1)
* 3) Если вычисленная ячейка пустая, то вернем false, если там есть связный список
 * с одним  элементом в голове,
 * то сравним его с тем который ищем через equals и если они одинаковые, то вернем тру O(1)
 *
 *
 * Если в связном списке больше чем 1 элемент, то будем перебирать все и сравнивать и если
 * найдем то вернем тру иначе фолз O(n)
 *
 * 1) У двух одинаковых объектов всегда одинаковый хэшкод
 * 2) У одного объекта хэшкод всегда постоянен
 * Хэшкод это быстрый способ сравнения объектов :
 * 1) если у двух объектов хэшкоды разные, то объекты точно разные!!!
 * 2) если у двух объектов хэшкоды одинаковые, то тогда нужно сравнить
 * эти объекты через equals, так как это могут быть разные объекты, а хэшкод
 * будет коллизией
 *
 * Изначально элементов 16 , когда мы достигаем заполнения 75%, то внутренний массив
 * увеличивается в 2 раза до 32 и так как позиция элемента (индекс ячейки где он хранится),
 * зависит от хэшкода и длины массива, то при изменении размера, для всех элементов
 * что хранятся в нашем сете будут пересчитаны индексы ячеек, те они переместятся в новые ячейки
 *
 * A - 66
 * B - 67
 * C - 68
 * D - 69
 *
 */
public class HashSetExample {

    public static void main(String[] args) {
        Set<String> stringSet = new HashSet<>();
        stringSet.add("A");
        stringSet.add("C");
        stringSet.add("F"); // 72 + 10 == index 5
        stringSet.add("D");
        stringSet.add("A");
        stringSet.add("e");
        System.out.println(stringSet);

        System.out.println("Set contains F " +stringSet.contains("F"));

        Set<Integer> integerSet = new HashSet<>();
        integerSet.add(4);
        integerSet.add(2);
        integerSet.add(-7);
        integerSet.add(9);
        integerSet.remove(9);
        System.out.println(integerSet);

        Hashtable<Object, Object> objectObjectHashtable = new Hashtable<>();
    }
}
